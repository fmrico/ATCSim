// **********************************************************************
//
// Copyright (c) 2003-2018 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.1
//
// <auto-generated>
//
// Generated from file `ATCDisplay.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __ATCDisplay_h__
#define __ATCDisplay_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace ATCDisplay
{

class AirportInterface;
class AirportInterfacePrx;

}

namespace ATCDisplay
{

struct ATCDPosition
{
    float x;
    float y;
    float z;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const float&, const float&, const float&> ice_tuple() const
    {
        return std::tie(x, y, z);
    }
};

using ATCDRoute = ::std::vector<ATCDPosition>;

struct ATCDStorm
{
    bool valid;
    float speed;
    ATCDPosition pos;
    float bearing;
    float radious;
    float height;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const bool&, const float&, const ATCDPosition&, const float&, const float&, const float&> ice_tuple() const
    {
        return std::tie(valid, speed, pos, bearing, radious, height);
    }
};

struct ATCDFlight
{
    float points;
    float speed;
    bool focused;
    ::std::string id;
    ATCDPosition pos;
    float inclination;
    float bearing;
    float collisionRadious;
    ATCDRoute flightRoute;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const float&, const float&, const bool&, const ::std::string&, const ATCDPosition&, const float&, const float&, const float&, const ATCDRoute&> ice_tuple() const
    {
        return std::tie(points, speed, focused, id, pos, inclination, bearing, collisionRadious, flightRoute);
    }
};

using ATCDFlights = ::std::vector<ATCDFlight>;

struct ATCDLandStrip
{
    ATCDPosition pos;
    float width;
    float length;
    float orientation;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ATCDPosition&, const float&, const float&, const float&> ice_tuple() const
    {
        return std::tie(pos, width, length, orientation);
    }
};

using ATCDLandStrips = ::std::vector<ATCDLandStrip>;

struct ATCDAirport
{
    ATCDLandStrips airportLandstrips;
    float radious;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ATCDLandStrips&, const float&> ice_tuple() const
    {
        return std::tie(airportLandstrips, radious);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace ATCDisplay
{

class AirportInterface : public virtual ::Ice::Object
{
public:

    using ProxyType = AirportInterfacePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ATCDFlights getFlights(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getFlights(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ATCDStorm getStorm(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getStorm(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ATCDAirport getAirportInfo(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getAirportInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateSimT(float inc, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateSimT(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void NextFocus(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_NextFocus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual float getSimT(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getSimT(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int getMaxFlights(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getMaxFlights(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int getPoints(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getPoints(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace ATCDisplay
{

class AirportInterfacePrx : public virtual ::Ice::Proxy<AirportInterfacePrx, ::Ice::ObjectPrx>
{
public:

    ATCDFlights getFlights(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ATCDFlights>(true, this, &AirportInterfacePrx::_iceI_getFlights, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getFlightsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ATCDFlights>>().get_future())
    {
        return _makePromiseOutgoing<ATCDFlights, P>(false, this, &AirportInterfacePrx::_iceI_getFlights, context);
    }

    ::std::function<void()>
    getFlightsAsync(::std::function<void(ATCDFlights)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ATCDFlights>(response, ex, sent, this, &AirportInterfacePrx::_iceI_getFlights, context);
    }

    /// \cond INTERNAL
    void _iceI_getFlights(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ATCDFlights>>&, const ::Ice::Context&);
    /// \endcond

    ATCDStorm getStorm(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ATCDStorm>(true, this, &AirportInterfacePrx::_iceI_getStorm, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getStormAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ATCDStorm>>().get_future())
    {
        return _makePromiseOutgoing<ATCDStorm, P>(false, this, &AirportInterfacePrx::_iceI_getStorm, context);
    }

    ::std::function<void()>
    getStormAsync(::std::function<void(ATCDStorm)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ATCDStorm>(response, ex, sent, this, &AirportInterfacePrx::_iceI_getStorm, context);
    }

    /// \cond INTERNAL
    void _iceI_getStorm(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ATCDStorm>>&, const ::Ice::Context&);
    /// \endcond

    ATCDAirport getAirportInfo(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ATCDAirport>(true, this, &AirportInterfacePrx::_iceI_getAirportInfo, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getAirportInfoAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ATCDAirport>>().get_future())
    {
        return _makePromiseOutgoing<ATCDAirport, P>(false, this, &AirportInterfacePrx::_iceI_getAirportInfo, context);
    }

    ::std::function<void()>
    getAirportInfoAsync(::std::function<void(ATCDAirport)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ATCDAirport>(response, ex, sent, this, &AirportInterfacePrx::_iceI_getAirportInfo, context);
    }

    /// \cond INTERNAL
    void _iceI_getAirportInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ATCDAirport>>&, const ::Ice::Context&);
    /// \endcond

    void UpdateSimT(float inc, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &AirportInterfacePrx::_iceI_UpdateSimT, inc, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateSimTAsync(float inc, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &AirportInterfacePrx::_iceI_UpdateSimT, inc, context);
    }

    ::std::function<void()>
    UpdateSimTAsync(float inc,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &AirportInterfacePrx::_iceI_UpdateSimT, inc, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateSimT(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, float, const ::Ice::Context&);
    /// \endcond

    void NextFocus(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &AirportInterfacePrx::_iceI_NextFocus, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto NextFocusAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &AirportInterfacePrx::_iceI_NextFocus, context);
    }

    ::std::function<void()>
    NextFocusAsync(::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &AirportInterfacePrx::_iceI_NextFocus, context);
    }

    /// \cond INTERNAL
    void _iceI_NextFocus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    float getSimT(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<float>(true, this, &AirportInterfacePrx::_iceI_getSimT, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getSimTAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<float>>().get_future())
    {
        return _makePromiseOutgoing<float, P>(false, this, &AirportInterfacePrx::_iceI_getSimT, context);
    }

    ::std::function<void()>
    getSimTAsync(::std::function<void(float)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<float>(response, ex, sent, this, &AirportInterfacePrx::_iceI_getSimT, context);
    }

    /// \cond INTERNAL
    void _iceI_getSimT(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<float>>&, const ::Ice::Context&);
    /// \endcond

    int getMaxFlights(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &AirportInterfacePrx::_iceI_getMaxFlights, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getMaxFlightsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &AirportInterfacePrx::_iceI_getMaxFlights, context);
    }

    ::std::function<void()>
    getMaxFlightsAsync(::std::function<void(int)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(response, ex, sent, this, &AirportInterfacePrx::_iceI_getMaxFlights, context);
    }

    /// \cond INTERNAL
    void _iceI_getMaxFlights(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    int getPoints(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &AirportInterfacePrx::_iceI_getPoints, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getPointsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &AirportInterfacePrx::_iceI_getPoints, context);
    }

    ::std::function<void()>
    getPointsAsync(::std::function<void(int)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(response, ex, sent, this, &AirportInterfacePrx::_iceI_getPoints, context);
    }

    /// \cond INTERNAL
    void _iceI_getPoints(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    AirportInterfacePrx() = default;
    friend ::std::shared_ptr<AirportInterfacePrx> IceInternal::createProxy<AirportInterfacePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::ATCDisplay::ATCDPosition>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::ATCDisplay::ATCDPosition, S>
{
    static void read(S* istr, ::ATCDisplay::ATCDPosition& v)
    {
        istr->readAll(v.x, v.y, v.z);
    }
};

template<>
struct StreamableTraits<::ATCDisplay::ATCDStorm>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 29;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::ATCDisplay::ATCDStorm, S>
{
    static void read(S* istr, ::ATCDisplay::ATCDStorm& v)
    {
        istr->readAll(v.valid, v.speed, v.pos, v.bearing, v.radious, v.height);
    }
};

template<>
struct StreamableTraits<::ATCDisplay::ATCDFlight>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 35;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::ATCDisplay::ATCDFlight, S>
{
    static void read(S* istr, ::ATCDisplay::ATCDFlight& v)
    {
        istr->readAll(v.points, v.speed, v.focused, v.id, v.pos, v.inclination, v.bearing, v.collisionRadious, v.flightRoute);
    }
};

template<>
struct StreamableTraits<::ATCDisplay::ATCDLandStrip>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 24;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::ATCDisplay::ATCDLandStrip, S>
{
    static void read(S* istr, ::ATCDisplay::ATCDLandStrip& v)
    {
        istr->readAll(v.pos, v.width, v.length, v.orientation);
    }
};

template<>
struct StreamableTraits<::ATCDisplay::ATCDAirport>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::ATCDisplay::ATCDAirport, S>
{
    static void read(S* istr, ::ATCDisplay::ATCDAirport& v)
    {
        istr->readAll(v.airportLandstrips, v.radious);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace ATCDisplay
{

using AirportInterfacePtr = ::std::shared_ptr<AirportInterface>;
using AirportInterfacePrxPtr = ::std::shared_ptr<AirportInterfacePrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace ATCDisplay
{

class AirportInterface;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::ATCDisplay::AirportInterface>&);
::IceProxy::Ice::Object* upCast(::IceProxy::ATCDisplay::AirportInterface*);
/// \endcond

}

}

namespace ATCDisplay
{

class AirportInterface;
/// \cond INTERNAL
::Ice::Object* upCast(AirportInterface*);
/// \endcond
typedef ::IceInternal::Handle< AirportInterface> AirportInterfacePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::ATCDisplay::AirportInterface> AirportInterfacePrx;
typedef AirportInterfacePrx AirportInterfacePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(AirportInterfacePtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace ATCDisplay
{

struct ATCDPosition
{
    ::Ice::Float x;
    ::Ice::Float y;
    ::Ice::Float z;
};

typedef ::std::vector<ATCDisplay::ATCDPosition> ATCDRoute;

struct ATCDStorm
{
    bool valid;
    ::Ice::Float speed;
    ATCDPosition pos;
    ::Ice::Float bearing;
    ::Ice::Float radious;
    ::Ice::Float height;
};

struct ATCDFlight
{
    ::Ice::Float points;
    ::Ice::Float speed;
    bool focused;
    ::std::string id;
    ATCDPosition pos;
    ::Ice::Float inclination;
    ::Ice::Float bearing;
    ::Ice::Float collisionRadious;
    ATCDRoute flightRoute;
};

typedef ::std::vector<ATCDisplay::ATCDFlight> ATCDFlights;

struct ATCDLandStrip
{
    ATCDPosition pos;
    ::Ice::Float width;
    ::Ice::Float length;
    ::Ice::Float orientation;
};

typedef ::std::vector<ATCDisplay::ATCDLandStrip> ATCDLandStrips;

struct ATCDAirport
{
    ATCDLandStrips airportLandstrips;
    ::Ice::Float radious;
};

}

namespace ATCDisplay
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getFlights.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getFlights.
 */
class Callback_AirportInterface_getFlights_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_AirportInterface_getFlights_Base> Callback_AirportInterface_getFlightsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getStorm.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getStorm.
 */
class Callback_AirportInterface_getStorm_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_AirportInterface_getStorm_Base> Callback_AirportInterface_getStormPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getAirportInfo.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getAirportInfo.
 */
class Callback_AirportInterface_getAirportInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_AirportInterface_getAirportInfo_Base> Callback_AirportInterface_getAirportInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_UpdateSimT.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_UpdateSimT.
 */
class Callback_AirportInterface_UpdateSimT_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_AirportInterface_UpdateSimT_Base> Callback_AirportInterface_UpdateSimTPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_NextFocus.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_NextFocus.
 */
class Callback_AirportInterface_NextFocus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_AirportInterface_NextFocus_Base> Callback_AirportInterface_NextFocusPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getSimT.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getSimT.
 */
class Callback_AirportInterface_getSimT_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_AirportInterface_getSimT_Base> Callback_AirportInterface_getSimTPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getMaxFlights.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getMaxFlights.
 */
class Callback_AirportInterface_getMaxFlights_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_AirportInterface_getMaxFlights_Base> Callback_AirportInterface_getMaxFlightsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getPoints.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getPoints.
 */
class Callback_AirportInterface_getPoints_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_AirportInterface_getPoints_Base> Callback_AirportInterface_getPointsPtr;

}

namespace IceProxy
{

namespace ATCDisplay
{

class AirportInterface : public virtual ::Ice::Proxy<AirportInterface, ::IceProxy::Ice::Object>
{
public:

    ::ATCDisplay::ATCDFlights getFlights(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getFlights(_iceI_begin_getFlights(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getFlights(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getFlights(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFlights(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFlights(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFlights(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFlights(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFlights(const ::ATCDisplay::Callback_AirportInterface_getFlightsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFlights(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFlights(const ::Ice::Context& context, const ::ATCDisplay::Callback_AirportInterface_getFlightsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFlights(context, cb, cookie);
    }

    ::ATCDisplay::ATCDFlights end_getFlights(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getFlights(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::ATCDisplay::ATCDStorm getStorm(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getStorm(_iceI_begin_getStorm(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getStorm(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getStorm(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStorm(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStorm(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStorm(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStorm(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStorm(const ::ATCDisplay::Callback_AirportInterface_getStormPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStorm(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStorm(const ::Ice::Context& context, const ::ATCDisplay::Callback_AirportInterface_getStormPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStorm(context, cb, cookie);
    }

    ::ATCDisplay::ATCDStorm end_getStorm(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getStorm(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::ATCDisplay::ATCDAirport getAirportInfo(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getAirportInfo(_iceI_begin_getAirportInfo(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getAirportInfo(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getAirportInfo(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAirportInfo(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAirportInfo(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAirportInfo(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAirportInfo(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAirportInfo(const ::ATCDisplay::Callback_AirportInterface_getAirportInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAirportInfo(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAirportInfo(const ::Ice::Context& context, const ::ATCDisplay::Callback_AirportInterface_getAirportInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAirportInfo(context, cb, cookie);
    }

    ::ATCDisplay::ATCDAirport end_getAirportInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getAirportInfo(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateSimT(::Ice::Float inc, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateSimT(_iceI_begin_UpdateSimT(inc, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateSimT(::Ice::Float inc, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateSimT(inc, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateSimT(::Ice::Float inc, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateSimT(inc, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateSimT(::Ice::Float inc, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateSimT(inc, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateSimT(::Ice::Float inc, const ::ATCDisplay::Callback_AirportInterface_UpdateSimTPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateSimT(inc, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateSimT(::Ice::Float inc, const ::Ice::Context& context, const ::ATCDisplay::Callback_AirportInterface_UpdateSimTPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateSimT(inc, context, cb, cookie);
    }

    void end_UpdateSimT(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateSimT(::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void NextFocus(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_NextFocus(_iceI_begin_NextFocus(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_NextFocus(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_NextFocus(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_NextFocus(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_NextFocus(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_NextFocus(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_NextFocus(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_NextFocus(const ::ATCDisplay::Callback_AirportInterface_NextFocusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_NextFocus(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_NextFocus(const ::Ice::Context& context, const ::ATCDisplay::Callback_AirportInterface_NextFocusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_NextFocus(context, cb, cookie);
    }

    void end_NextFocus(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_NextFocus(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Float getSimT(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getSimT(_iceI_begin_getSimT(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getSimT(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getSimT(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSimT(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSimT(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getSimT(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSimT(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getSimT(const ::ATCDisplay::Callback_AirportInterface_getSimTPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSimT(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getSimT(const ::Ice::Context& context, const ::ATCDisplay::Callback_AirportInterface_getSimTPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSimT(context, cb, cookie);
    }

    ::Ice::Float end_getSimT(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getSimT(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int getMaxFlights(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getMaxFlights(_iceI_begin_getMaxFlights(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getMaxFlights(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getMaxFlights(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMaxFlights(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMaxFlights(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMaxFlights(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMaxFlights(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMaxFlights(const ::ATCDisplay::Callback_AirportInterface_getMaxFlightsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMaxFlights(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMaxFlights(const ::Ice::Context& context, const ::ATCDisplay::Callback_AirportInterface_getMaxFlightsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMaxFlights(context, cb, cookie);
    }

    ::Ice::Int end_getMaxFlights(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getMaxFlights(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int getPoints(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getPoints(_iceI_begin_getPoints(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getPoints(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getPoints(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPoints(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPoints(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPoints(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPoints(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPoints(const ::ATCDisplay::Callback_AirportInterface_getPointsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPoints(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPoints(const ::Ice::Context& context, const ::ATCDisplay::Callback_AirportInterface_getPointsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPoints(context, cb, cookie);
    }

    ::Ice::Int end_getPoints(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getPoints(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace ATCDisplay
{

class AirportInterface : public virtual ::Ice::Object
{
public:

    typedef AirportInterfacePrx ProxyType;
    typedef AirportInterfacePtr PointerType;

    virtual ~AirportInterface();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ATCDFlights getFlights(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getFlights(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ATCDStorm getStorm(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getStorm(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ATCDAirport getAirportInfo(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getAirportInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateSimT(::Ice::Float inc, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateSimT(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void NextFocus(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_NextFocus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Float getSimT(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getSimT(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int getMaxFlights(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getMaxFlights(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int getPoints(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getPoints(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const AirportInterface& lhs, const AirportInterface& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const AirportInterface& lhs, const AirportInterface& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::ATCDisplay::ATCDPosition>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::ATCDisplay::ATCDPosition, S>
{
    static void write(S* ostr, const ::ATCDisplay::ATCDPosition& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.z);
    }
};

template<typename S>
struct StreamReader< ::ATCDisplay::ATCDPosition, S>
{
    static void read(S* istr, ::ATCDisplay::ATCDPosition& v)
    {
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.z);
    }
};

template<>
struct StreamableTraits< ::ATCDisplay::ATCDStorm>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 29;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::ATCDisplay::ATCDStorm, S>
{
    static void write(S* ostr, const ::ATCDisplay::ATCDStorm& v)
    {
        ostr->write(v.valid);
        ostr->write(v.speed);
        ostr->write(v.pos);
        ostr->write(v.bearing);
        ostr->write(v.radious);
        ostr->write(v.height);
    }
};

template<typename S>
struct StreamReader< ::ATCDisplay::ATCDStorm, S>
{
    static void read(S* istr, ::ATCDisplay::ATCDStorm& v)
    {
        istr->read(v.valid);
        istr->read(v.speed);
        istr->read(v.pos);
        istr->read(v.bearing);
        istr->read(v.radious);
        istr->read(v.height);
    }
};

template<>
struct StreamableTraits< ::ATCDisplay::ATCDFlight>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 35;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::ATCDisplay::ATCDFlight, S>
{
    static void write(S* ostr, const ::ATCDisplay::ATCDFlight& v)
    {
        ostr->write(v.points);
        ostr->write(v.speed);
        ostr->write(v.focused);
        ostr->write(v.id);
        ostr->write(v.pos);
        ostr->write(v.inclination);
        ostr->write(v.bearing);
        ostr->write(v.collisionRadious);
        ostr->write(v.flightRoute);
    }
};

template<typename S>
struct StreamReader< ::ATCDisplay::ATCDFlight, S>
{
    static void read(S* istr, ::ATCDisplay::ATCDFlight& v)
    {
        istr->read(v.points);
        istr->read(v.speed);
        istr->read(v.focused);
        istr->read(v.id);
        istr->read(v.pos);
        istr->read(v.inclination);
        istr->read(v.bearing);
        istr->read(v.collisionRadious);
        istr->read(v.flightRoute);
    }
};

template<>
struct StreamableTraits< ::ATCDisplay::ATCDLandStrip>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 24;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::ATCDisplay::ATCDLandStrip, S>
{
    static void write(S* ostr, const ::ATCDisplay::ATCDLandStrip& v)
    {
        ostr->write(v.pos);
        ostr->write(v.width);
        ostr->write(v.length);
        ostr->write(v.orientation);
    }
};

template<typename S>
struct StreamReader< ::ATCDisplay::ATCDLandStrip, S>
{
    static void read(S* istr, ::ATCDisplay::ATCDLandStrip& v)
    {
        istr->read(v.pos);
        istr->read(v.width);
        istr->read(v.length);
        istr->read(v.orientation);
    }
};

template<>
struct StreamableTraits< ::ATCDisplay::ATCDAirport>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::ATCDisplay::ATCDAirport, S>
{
    static void write(S* ostr, const ::ATCDisplay::ATCDAirport& v)
    {
        ostr->write(v.airportLandstrips);
        ostr->write(v.radious);
    }
};

template<typename S>
struct StreamReader< ::ATCDisplay::ATCDAirport, S>
{
    static void read(S* istr, ::ATCDisplay::ATCDAirport& v)
    {
        istr->read(v.airportLandstrips);
        istr->read(v.radious);
    }
};

}
/// \endcond

namespace ATCDisplay
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getFlights.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getFlights.
 */
template<class T>
class CallbackNC_AirportInterface_getFlights : public Callback_AirportInterface_getFlights_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ATCDFlights&);

    CallbackNC_AirportInterface_getFlights(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        AirportInterfacePrx proxy = AirportInterfacePrx::uncheckedCast(result->getProxy());
        ATCDFlights ret;
        try
        {
            ret = proxy->end_getFlights(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getFlights.
 */
template<class T> Callback_AirportInterface_getFlightsPtr
newCallback_AirportInterface_getFlights(const IceUtil::Handle<T>& instance, void (T::*cb)(const ATCDFlights&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_getFlights<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getFlights.
 */
template<class T> Callback_AirportInterface_getFlightsPtr
newCallback_AirportInterface_getFlights(T* instance, void (T::*cb)(const ATCDFlights&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_getFlights<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getFlights.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getFlights.
 */
template<class T, typename CT>
class Callback_AirportInterface_getFlights : public Callback_AirportInterface_getFlights_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ATCDFlights&, const CT&);

    Callback_AirportInterface_getFlights(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        AirportInterfacePrx proxy = AirportInterfacePrx::uncheckedCast(result->getProxy());
        ATCDFlights ret;
        try
        {
            ret = proxy->end_getFlights(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getFlights.
 */
template<class T, typename CT> Callback_AirportInterface_getFlightsPtr
newCallback_AirportInterface_getFlights(const IceUtil::Handle<T>& instance, void (T::*cb)(const ATCDFlights&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_getFlights<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getFlights.
 */
template<class T, typename CT> Callback_AirportInterface_getFlightsPtr
newCallback_AirportInterface_getFlights(T* instance, void (T::*cb)(const ATCDFlights&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_getFlights<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getStorm.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getStorm.
 */
template<class T>
class CallbackNC_AirportInterface_getStorm : public Callback_AirportInterface_getStorm_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ATCDStorm&);

    CallbackNC_AirportInterface_getStorm(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        AirportInterfacePrx proxy = AirportInterfacePrx::uncheckedCast(result->getProxy());
        ATCDStorm ret;
        try
        {
            ret = proxy->end_getStorm(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getStorm.
 */
template<class T> Callback_AirportInterface_getStormPtr
newCallback_AirportInterface_getStorm(const IceUtil::Handle<T>& instance, void (T::*cb)(const ATCDStorm&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_getStorm<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getStorm.
 */
template<class T> Callback_AirportInterface_getStormPtr
newCallback_AirportInterface_getStorm(T* instance, void (T::*cb)(const ATCDStorm&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_getStorm<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getStorm.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getStorm.
 */
template<class T, typename CT>
class Callback_AirportInterface_getStorm : public Callback_AirportInterface_getStorm_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ATCDStorm&, const CT&);

    Callback_AirportInterface_getStorm(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        AirportInterfacePrx proxy = AirportInterfacePrx::uncheckedCast(result->getProxy());
        ATCDStorm ret;
        try
        {
            ret = proxy->end_getStorm(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getStorm.
 */
template<class T, typename CT> Callback_AirportInterface_getStormPtr
newCallback_AirportInterface_getStorm(const IceUtil::Handle<T>& instance, void (T::*cb)(const ATCDStorm&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_getStorm<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getStorm.
 */
template<class T, typename CT> Callback_AirportInterface_getStormPtr
newCallback_AirportInterface_getStorm(T* instance, void (T::*cb)(const ATCDStorm&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_getStorm<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getAirportInfo.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getAirportInfo.
 */
template<class T>
class CallbackNC_AirportInterface_getAirportInfo : public Callback_AirportInterface_getAirportInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ATCDAirport&);

    CallbackNC_AirportInterface_getAirportInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        AirportInterfacePrx proxy = AirportInterfacePrx::uncheckedCast(result->getProxy());
        ATCDAirport ret;
        try
        {
            ret = proxy->end_getAirportInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getAirportInfo.
 */
template<class T> Callback_AirportInterface_getAirportInfoPtr
newCallback_AirportInterface_getAirportInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ATCDAirport&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_getAirportInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getAirportInfo.
 */
template<class T> Callback_AirportInterface_getAirportInfoPtr
newCallback_AirportInterface_getAirportInfo(T* instance, void (T::*cb)(const ATCDAirport&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_getAirportInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getAirportInfo.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getAirportInfo.
 */
template<class T, typename CT>
class Callback_AirportInterface_getAirportInfo : public Callback_AirportInterface_getAirportInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ATCDAirport&, const CT&);

    Callback_AirportInterface_getAirportInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        AirportInterfacePrx proxy = AirportInterfacePrx::uncheckedCast(result->getProxy());
        ATCDAirport ret;
        try
        {
            ret = proxy->end_getAirportInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getAirportInfo.
 */
template<class T, typename CT> Callback_AirportInterface_getAirportInfoPtr
newCallback_AirportInterface_getAirportInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ATCDAirport&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_getAirportInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getAirportInfo.
 */
template<class T, typename CT> Callback_AirportInterface_getAirportInfoPtr
newCallback_AirportInterface_getAirportInfo(T* instance, void (T::*cb)(const ATCDAirport&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_getAirportInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_UpdateSimT.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_UpdateSimT.
 */
template<class T>
class CallbackNC_AirportInterface_UpdateSimT : public Callback_AirportInterface_UpdateSimT_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_AirportInterface_UpdateSimT(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_UpdateSimT.
 */
template<class T> Callback_AirportInterface_UpdateSimTPtr
newCallback_AirportInterface_UpdateSimT(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_UpdateSimT<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_UpdateSimT.
 */
template<class T> Callback_AirportInterface_UpdateSimTPtr
newCallback_AirportInterface_UpdateSimT(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_UpdateSimT<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_UpdateSimT.
 */
template<class T> Callback_AirportInterface_UpdateSimTPtr
newCallback_AirportInterface_UpdateSimT(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_UpdateSimT<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_UpdateSimT.
 */
template<class T> Callback_AirportInterface_UpdateSimTPtr
newCallback_AirportInterface_UpdateSimT(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_UpdateSimT<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_UpdateSimT.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_UpdateSimT.
 */
template<class T, typename CT>
class Callback_AirportInterface_UpdateSimT : public Callback_AirportInterface_UpdateSimT_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_AirportInterface_UpdateSimT(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_UpdateSimT.
 */
template<class T, typename CT> Callback_AirportInterface_UpdateSimTPtr
newCallback_AirportInterface_UpdateSimT(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_UpdateSimT<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_UpdateSimT.
 */
template<class T, typename CT> Callback_AirportInterface_UpdateSimTPtr
newCallback_AirportInterface_UpdateSimT(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_UpdateSimT<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_UpdateSimT.
 */
template<class T, typename CT> Callback_AirportInterface_UpdateSimTPtr
newCallback_AirportInterface_UpdateSimT(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_UpdateSimT<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_UpdateSimT.
 */
template<class T, typename CT> Callback_AirportInterface_UpdateSimTPtr
newCallback_AirportInterface_UpdateSimT(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_UpdateSimT<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_NextFocus.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_NextFocus.
 */
template<class T>
class CallbackNC_AirportInterface_NextFocus : public Callback_AirportInterface_NextFocus_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_AirportInterface_NextFocus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_NextFocus.
 */
template<class T> Callback_AirportInterface_NextFocusPtr
newCallback_AirportInterface_NextFocus(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_NextFocus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_NextFocus.
 */
template<class T> Callback_AirportInterface_NextFocusPtr
newCallback_AirportInterface_NextFocus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_NextFocus<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_NextFocus.
 */
template<class T> Callback_AirportInterface_NextFocusPtr
newCallback_AirportInterface_NextFocus(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_NextFocus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_NextFocus.
 */
template<class T> Callback_AirportInterface_NextFocusPtr
newCallback_AirportInterface_NextFocus(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_NextFocus<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_NextFocus.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_NextFocus.
 */
template<class T, typename CT>
class Callback_AirportInterface_NextFocus : public Callback_AirportInterface_NextFocus_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_AirportInterface_NextFocus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_NextFocus.
 */
template<class T, typename CT> Callback_AirportInterface_NextFocusPtr
newCallback_AirportInterface_NextFocus(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_NextFocus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_NextFocus.
 */
template<class T, typename CT> Callback_AirportInterface_NextFocusPtr
newCallback_AirportInterface_NextFocus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_NextFocus<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_NextFocus.
 */
template<class T, typename CT> Callback_AirportInterface_NextFocusPtr
newCallback_AirportInterface_NextFocus(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_NextFocus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_NextFocus.
 */
template<class T, typename CT> Callback_AirportInterface_NextFocusPtr
newCallback_AirportInterface_NextFocus(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_NextFocus<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getSimT.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getSimT.
 */
template<class T>
class CallbackNC_AirportInterface_getSimT : public Callback_AirportInterface_getSimT_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_AirportInterface_getSimT(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        AirportInterfacePrx proxy = AirportInterfacePrx::uncheckedCast(result->getProxy());
        ::Ice::Float ret;
        try
        {
            ret = proxy->end_getSimT(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getSimT.
 */
template<class T> Callback_AirportInterface_getSimTPtr
newCallback_AirportInterface_getSimT(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_getSimT<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getSimT.
 */
template<class T> Callback_AirportInterface_getSimTPtr
newCallback_AirportInterface_getSimT(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_getSimT<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getSimT.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getSimT.
 */
template<class T, typename CT>
class Callback_AirportInterface_getSimT : public Callback_AirportInterface_getSimT_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_AirportInterface_getSimT(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        AirportInterfacePrx proxy = AirportInterfacePrx::uncheckedCast(result->getProxy());
        ::Ice::Float ret;
        try
        {
            ret = proxy->end_getSimT(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getSimT.
 */
template<class T, typename CT> Callback_AirportInterface_getSimTPtr
newCallback_AirportInterface_getSimT(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_getSimT<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getSimT.
 */
template<class T, typename CT> Callback_AirportInterface_getSimTPtr
newCallback_AirportInterface_getSimT(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_getSimT<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getMaxFlights.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getMaxFlights.
 */
template<class T>
class CallbackNC_AirportInterface_getMaxFlights : public Callback_AirportInterface_getMaxFlights_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_AirportInterface_getMaxFlights(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        AirportInterfacePrx proxy = AirportInterfacePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getMaxFlights(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getMaxFlights.
 */
template<class T> Callback_AirportInterface_getMaxFlightsPtr
newCallback_AirportInterface_getMaxFlights(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_getMaxFlights<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getMaxFlights.
 */
template<class T> Callback_AirportInterface_getMaxFlightsPtr
newCallback_AirportInterface_getMaxFlights(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_getMaxFlights<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getMaxFlights.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getMaxFlights.
 */
template<class T, typename CT>
class Callback_AirportInterface_getMaxFlights : public Callback_AirportInterface_getMaxFlights_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_AirportInterface_getMaxFlights(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        AirportInterfacePrx proxy = AirportInterfacePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getMaxFlights(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getMaxFlights.
 */
template<class T, typename CT> Callback_AirportInterface_getMaxFlightsPtr
newCallback_AirportInterface_getMaxFlights(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_getMaxFlights<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getMaxFlights.
 */
template<class T, typename CT> Callback_AirportInterface_getMaxFlightsPtr
newCallback_AirportInterface_getMaxFlights(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_getMaxFlights<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getPoints.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getPoints.
 */
template<class T>
class CallbackNC_AirportInterface_getPoints : public Callback_AirportInterface_getPoints_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_AirportInterface_getPoints(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        AirportInterfacePrx proxy = AirportInterfacePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getPoints(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getPoints.
 */
template<class T> Callback_AirportInterface_getPointsPtr
newCallback_AirportInterface_getPoints(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_getPoints<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getPoints.
 */
template<class T> Callback_AirportInterface_getPointsPtr
newCallback_AirportInterface_getPoints(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AirportInterface_getPoints<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::ATCDisplay::AirportInterface::begin_getPoints.
 * Create a wrapper instance by calling ::ATCDisplay::newCallback_AirportInterface_getPoints.
 */
template<class T, typename CT>
class Callback_AirportInterface_getPoints : public Callback_AirportInterface_getPoints_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_AirportInterface_getPoints(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        AirportInterfacePrx proxy = AirportInterfacePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getPoints(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getPoints.
 */
template<class T, typename CT> Callback_AirportInterface_getPointsPtr
newCallback_AirportInterface_getPoints(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_getPoints<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::ATCDisplay::AirportInterface::begin_getPoints.
 */
template<class T, typename CT> Callback_AirportInterface_getPointsPtr
newCallback_AirportInterface_getPoints(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AirportInterface_getPoints<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
